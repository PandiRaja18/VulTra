import { VulnerabilityIssue, AnalysisResult, SecurityPattern } from '../types';
import { LoggingSensitivityChecker } from './loggingSensitivityChecker';
import { SemanticLoggingAnalyzer } from './semanticLoggingAnalyzer';


export class VulnerabilityScanner {
    private readonly CONSTANT_PATTERN = /static\s+final\s+\w+\s+([A-Za-z_][A-Za-z0-9_]*)\s*=/g;
    private readonly SENSITIVE_PATTERNS = [
        { pattern: /(?:api[_-]?key|apikey)\s*=\s*["']([^"']{8,})["']/gi, type: 'API Key' },
        { pattern: /(?:secret|password|pwd)\s*=\s*["']([^"']{8,})["']/gi, type: 'Secret/Password' },
        { pattern: /(?:token|auth[_-]?token)\s*=\s*["']([^"']{8,})["']/gi, type: 'Auth Token' }
    ];

    private semanticAnalyzer: SemanticLoggingAnalyzer;

    constructor() {
        this.semanticAnalyzer = new SemanticLoggingAnalyzer();
    }
    private securityPatterns: SecurityPattern[] = [
        // SQL Injection patterns
        {
            name: 'SQL Injection',
            pattern: /Statement\s+\w+\s*=\s*.*\.createStatement\(\)|executeQuery\(.*\+.*\)|executeUpdate\(.*\+.*\)/g,
            severity: 'high',
            description: 'Potential SQL injection vulnerability detected',
            suggestedFix: 'Use PreparedStatement with parameterized queries instead of string concatenation'
        },
        
        // XSS patterns
        {
            name: 'XSS Vulnerability',
            pattern: /response\.getWriter\(\)\.print\(.*request\.getParameter.*\)|out\.print\(.*request\.getParameter.*\)/g,
            severity: 'high',
            description: 'Potential XSS vulnerability - unescaped user input',
            suggestedFix: 'Escape user input using OWASP Java Encoder or similar library'
        },
        
        // Hardcoded secrets
        {
            name: 'Hardcoded Secrets',
            pattern: /(password|secret|key|token)\s*=\s*["'][^"']+["']/gi,
            severity: 'high',
            description: 'Hardcoded sensitive information detected',
            suggestedFix: 'Move sensitive data to configuration files or environment variables'
        },
        
        // Existing patterns...
        {
            name: 'Constant Naming',
            pattern: /private\s+static\s+final\s+\w+\s+([a-z][a-zA-Z0-9]*)\s*=/g,
            severity: 'low',
            description: 'Constant should follow UPPER_CASE_WITH_UNDERSCORES naming convention',
            suggestedFix: 'Rename constant to follow Java naming conventions (UPPER_CASE_WITH_UNDERSCORES)'
        },
        
        {
            name: 'Excessive Nesting',
            pattern: /(\s{12,})(if|for|while|switch)\s*\(/g,
            severity: 'medium',
            description: 'Excessive nesting detected - consider refactoring',
            suggestedFix: 'Extract methods or use early returns to reduce nesting complexity'
        },
        {
            name: 'Sensitive information',
            pattern: /(?:api[_-]?key|apikey)\s*=\s*["']([^"']{8,})["']|(?:secret|password|pwd)\s*=\s*["']([^"']{8,})["']|(?:token|auth[_-]?token)\s*=\s*["']([^"']{8,})["']/gi,
            severity: 'high',
            description: 'Sensitive information is been harcoded',
            suggestedFix: 'Try to remove or do some other modification, if it is for testing please ignore.'
        }

    ];

    public async generateSemanticLoggingReport(code: string): Promise<string> {
        return await this.semanticAnalyzer.generateSemanticReport(code);
    }

    public isSemanticModelReady(): boolean {
        return this.semanticAnalyzer.isModelReady();
    }

    public async analyze(code: string): Promise<AnalysisResult> {
        const issues: VulnerabilityIssue[] = [];

        // Run existing security pattern checks
        issues.push(...this.checkSecurityPatterns(code));
        
        // Run logging sensitivity checks
         try {
            issues.push(...await this.semanticAnalyzer.analyzeLoggingStatements(code));
        } catch (error) {
            console.error('Error in semantic analysis:', error);
        }        
        // return {
        //     fileName: '',
        //     issues,
        //     timestamp: new Date(),
        //     scanDuration: endTime - startTime
        // };
        return { 
            fileName: '', 
            issues,
            totalIssues: issues.length,
            timestamp: new Date()
        };
    }

    private checkSecurityPatterns(code: string): VulnerabilityIssue[] {
        const issues: VulnerabilityIssue[] = [];
        const lines = code.split('\n');

        this.securityPatterns.forEach(pattern => {
            lines.forEach((line, index) => {
                const matches = line.match(pattern.pattern);
                if (matches) {
                    matches.forEach(match => { 
                        issues.push({
                            lineNumber: index + 1,
                            description: pattern.description,
                            severity: pattern.severity,
                            suggestedFix: pattern.suggestedFix,
                            message: `Pattern mismatch detected: ${pattern.name}`,
                            fileName: '',
                            range: null,
                            diagnostic: null
                        });

                    });
                }
            });
        });

        return issues;
    }


    public async analyzeFile(filePath: string): Promise<AnalysisResult> {
        const fs = require('fs');
        const fileContent = fs.readFileSync(filePath, 'utf-8');
        const result = this.analyze(fileContent);
        (await result).fileName = filePath;
        return result;
    }

    private checkConstantNaming(content: string, issues: VulnerabilityIssue[]): void {
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
            let match: RegExpExecArray | null;
            const regex = new RegExp(this.CONSTANT_PATTERN);
            while ((match = regex.exec(line)) !== null) {
                const constantName = match[1];
                if (!/^[A-Z][A-Z0-9_]*$/.test(constantName)) {
                    issues.push({
                        fileName: '',
                        lineNumber: index + 1,
                        description: `Constant '${constantName}' should be in UPPER_CASE_WITH_UNDERSCORES format`,
                        severity: 'medium',
                        message: `Constant naming violation: ${constantName}`,
                        range: null,
                        suggestedFix: `Rename to ${constantName.toUpperCase()}`,
                        diagnostic: null
                    });
                }
            }
        });
    }

    private checkExcessiveNesting(content: string, issues: VulnerabilityIssue[]): void {
        const lines = content.split('\n');
        const maxDepth = 5;
        let methodDepth = 0;
        let isInsideMethod = false;
        
        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            
            // Skip class-level braces and method declarations
            if (this.isClassDeclaration(trimmedLine) || this.isMethodDeclaration(trimmedLine)) {
                if (this.isMethodDeclaration(trimmedLine)) {
                    isInsideMethod = true;
                    methodDepth = 0; // Reset method depth
                }
                return;
            }
            
            // Only count nesting inside methods
            if (!isInsideMethod) {
                // Check if we're entering a method body
                if (trimmedLine.includes('{') && this.isPreviousLineMethod(lines, index)) {
                    isInsideMethod = true;
                    methodDepth = 0;
                }
                return;
            }
            
            // Check for control structures only inside methods
            const controlStructures = [
                /\bif\s*\(/,
                /\belse\s+if\s*\(/,
                /\belse\s*{/,
                /\bfor\s*\(/,
                /\bwhile\s*\(/,
                /\bdo\s*{/,
                /\bswitch\s*\(/,
                /\btry\s*{/,
                /\bcatch\s*\(/
            ];

            const hasControlStructure = controlStructures.some(pattern => pattern.test(trimmedLine));
            
            // Count opening braces for control structures
            if (hasControlStructure || (trimmedLine.includes('{') && !this.isMethodDeclaration(trimmedLine))) {
                methodDepth++;
                
                if (methodDepth > maxDepth) {
                    issues.push({
                        fileName: '',
                        lineNumber: index + 1,
                        description: `Excessive nesting detected (depth: ${methodDepth}, max: ${maxDepth}). Consider refactoring to reduce complexity.`,
                        severity: 'high',
                        message: `Nesting too deep: ${methodDepth} levels`,
                        range: null,
                        suggestedFix: 'Consider refactoring to reduce nesting (extract methods, use early returns, etc.)',
                        diagnostic: null
                    });
                }
            }

            // Count closing braces
            const closeBraces = (trimmedLine.match(/}/g) || []).length;
            if (closeBraces > 0) {
                methodDepth = Math.max(0, methodDepth - closeBraces);
                
                // Check if we're exiting the method
                if (methodDepth === 0 && isInsideMethod) {
                    isInsideMethod = false;
                }
            }
        });
    }

    private isClassDeclaration(line: string): boolean {
        return /^\s*(public|private|protected)?\s*(abstract|final)?\s*class\s+\w+/.test(line);
    }

    private isMethodDeclaration(line: string): boolean {
        return /^\s*(public|private|protected|static|final|\s)*\s+\w+\s+\w+\s*\([^)]*\)\s*(throws\s+\w+)?\s*{?/.test(line);
    }

    private isPreviousLineMethod(lines: string[], currentIndex: number): boolean {
        if (currentIndex === 0) return false;
        const previousLine = lines[currentIndex - 1].trim();
        return this.isMethodDeclaration(previousLine) || 
               /^\s*(public|private|protected|static|final|\s)*\s+\w+\s+\w+\s*\([^)]*\)\s*(throws\s+\w+)?\s*$/.test(previousLine);
    }

    private checkSensitiveInformation(content: string, issues: VulnerabilityIssue[]): void {
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
            this.SENSITIVE_PATTERNS.forEach(({ pattern, type }) => {
                let match: RegExpExecArray | null;
                while ((match = pattern.exec(line)) !== null) {
                    const value = match[1];
                    issues.push({
                        fileName: '',
                        lineNumber: index + 1,
                        description: `Potential hardcoded ${type} detected`,
                        severity: 'high',
                        message: `Hardcoded ${type}: ${value.substring(0, 10)}...`,
                        range: null,
                        suggestedFix: 'Move sensitive data to configuration files',
                        diagnostic: null
                    });
                }
            });
        });
    }
}